<!DOCTYPE html>
<html>
<head>
  <title>Call Recorder</title>
  <style>
    body { background: #000; color: #fff; font-family: sans-serif; padding: 20px; }
    #status { margin: 20px 0; }
    .recording { color: #f44336; }
    .connected { color: #4caf50; }
  </style>
</head>
<body>
  <h1>Ghost Recorder</h1>
  <div id="status">Initializing...</div>
  <div id="participants"></div>

  <!-- Hidden video/audio elements for streams -->
  <video id="localVideo" autoplay muted playsinline style="display:none;"></video>
  <div id="remoteVideos" style="display:none;"></div>

  <script>
    // Configuration passed via URL params
    const params = new URLSearchParams(window.location.search);
    const API_URL = params.get('apiUrl') || 'http://localhost:3001';
    const GROUP_ID = params.get('groupId');
    const CALL_ID = params.get('callId');
    const CALL_TYPE = params.get('callType') || 'phone'; // 'phone' or 'video'
    const AUTH_TOKEN = params.get('token');

    // State
    let peerConnections = {};
    let localStream = null;
    let mediaRecorder = null;
    let recordedChunks = [];
    let isRecording = false;
    let audioContext = null;
    let mixedDestination = null;

    const statusEl = document.getElementById('status');

    function updateStatus(msg, className = '') {
      statusEl.textContent = msg;
      statusEl.className = className;
      console.log('[Recorder]', msg);
    }

    async function init() {
      try {
        updateStatus('Getting media access...');

        // Get local media (audio only for ghost - we just need to join)
        localStream = await navigator.mediaDevices.getUserMedia({
          audio: true,
          video: false // Ghost doesn't need to send video
        });

        // Mute local audio output (we don't want to play our own audio)
        localStream.getAudioTracks().forEach(track => {
          track.enabled = false; // Mute outgoing audio
        });

        updateStatus('Connecting to signaling server...');
        await connectToCall();

      } catch (err) {
        updateStatus('Error: ' + err.message);
        console.error('[Recorder] Init error:', err);
      }
    }

    async function connectToCall() {
      try {
        // Get call participants via API
        const endpoint = CALL_TYPE === 'video' ? 'video-calls' : 'phone-calls';
        const response = await fetch(`${API_URL}/groups/${GROUP_ID}/${endpoint}`, {
          headers: { 'Authorization': `Bearer ${AUTH_TOKEN}` }
        });

        if (!response.ok) throw new Error('Failed to fetch call info');

        const data = await response.json();
        const calls = CALL_TYPE === 'video' ? data.videoCalls : data.phoneCalls;
        const call = calls?.find(c => c.callId === CALL_ID);

        if (!call) throw new Error('Call not found');
        if (call.status !== 'active') throw new Error('Call is not active');

        updateStatus('Connected. Starting recording...', 'connected');

        // Set up audio context for mixing streams
        setupAudioMixer();

        // Poll for WebRTC offers via signaling
        pollForSignals();

        // Start recording immediately
        setTimeout(startRecording, 1000);

      } catch (err) {
        updateStatus('Connection error: ' + err.message);
        console.error('[Recorder] Connect error:', err);
      }
    }

    function setupAudioMixer() {
      audioContext = new AudioContext();
      mixedDestination = audioContext.createMediaStreamDestination();
    }

    function addStreamToMixer(stream, label) {
      if (!audioContext || !mixedDestination) return;

      try {
        const audioTracks = stream.getAudioTracks();
        if (audioTracks.length > 0) {
          const source = audioContext.createMediaStreamSource(stream);
          source.connect(mixedDestination);
          console.log('[Recorder] Added stream to mixer:', label);
        }
      } catch (err) {
        console.error('[Recorder] Failed to add stream to mixer:', err);
      }
    }

    async function pollForSignals() {
      // Poll the signaling endpoint for WebRTC signals (using recorder-specific endpoint)
      const signalUrl = `${API_URL}/groups/${GROUP_ID}/${CALL_TYPE === 'video' ? 'video-calls' : 'phone-calls'}/${CALL_ID}/recorder-signal`;
      console.log('[Recorder] Signal polling URL:', signalUrl);

      const pollInterval = setInterval(async () => {
        try {
          const response = await fetch(signalUrl, {
            headers: { 'Authorization': `Bearer ${AUTH_TOKEN}` }
          });

          if (!response.ok) {
            console.error('[Recorder] Signal poll failed:', response.status, response.statusText);
            return;
          }

          const data = await response.json();
          if (data.signals && data.signals.length > 0) {
            console.log('[Recorder] Received', data.signals.length, 'signals');
            for (const signal of data.signals) {
              console.log('[Recorder] Processing signal:', signal.type, 'from', signal.from);
              await handleSignal(signal);
            }
          }
        } catch (err) {
          console.error('[Recorder] Signal poll error:', err.message || err);
        }
      }, 2000);

      // Store for cleanup
      window.signalPollInterval = pollInterval;
    }

    async function handleSignal(signal) {
      const { from: fromId, type, data } = signal;
      console.log('[Recorder] Handling signal:', type, 'from peer:', fromId);

      if (!peerConnections[fromId]) {
        // Create new peer connection for this participant
        const pc = new RTCPeerConnection({
          iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        });

        pc.ontrack = (event) => {
          console.log('[Recorder] Received track from', fromId);
          addStreamToMixer(event.streams[0], fromId);
        };

        pc.onicecandidate = async (event) => {
          if (event.candidate) {
            await sendSignal(fromId, 'ice-candidate', event.candidate);
          }
        };

        peerConnections[fromId] = pc;
      }

      const pc = peerConnections[fromId];

      if (type === 'offer') {
        await pc.setRemoteDescription(new RTCSessionDescription(data));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await sendSignal(fromId, 'answer', answer);
      } else if (type === 'answer') {
        await pc.setRemoteDescription(new RTCSessionDescription(data));
      } else if (type === 'ice-candidate') {
        await pc.addIceCandidate(new RTCIceCandidate(data));
      }
    }

    async function sendSignal(toId, type, data) {
      try {
        const endpoint = CALL_TYPE === 'video' ? 'video-calls' : 'phone-calls';
        await fetch(`${API_URL}/groups/${GROUP_ID}/${endpoint}/${CALL_ID}/recorder-signal`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${AUTH_TOKEN}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            targetPeerId: toId,
            type,
            data
          })
        });
      } catch (err) {
        console.error('[Recorder] Send signal error:', err);
      }
    }

    function startRecording() {
      if (isRecording || !mixedDestination) return;

      try {
        const stream = mixedDestination.stream;
        const mimeType = CALL_TYPE === 'video' ? 'video/webm;codecs=vp9' : 'audio/webm;codecs=opus';

        mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });

        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            recordedChunks.push(event.data);
          }
        };

        mediaRecorder.onstop = () => {
          uploadRecording();
        };

        mediaRecorder.start(1000); // Collect data every second
        isRecording = true;
        updateStatus('Recording in progress...', 'recording');

        // Expose stop function for Puppeteer
        window.stopRecording = stopRecording;
        window.isRecording = true;

      } catch (err) {
        console.error('[Recorder] Start recording error:', err);
        updateStatus('Recording failed: ' + err.message);
      }
    }

    function stopRecording() {
      return new Promise((resolve) => {
        if (!isRecording || !mediaRecorder) {
          resolve();
          return;
        }

        mediaRecorder.onstop = async () => {
          await uploadRecording();
          resolve();
        };

        mediaRecorder.stop();
        isRecording = false;
        window.isRecording = false;
        updateStatus('Recording stopped, uploading...');
      });
    }

    async function uploadRecording() {
      try {
        if (recordedChunks.length === 0) {
          console.log('[Recorder] No data to upload');
          return;
        }

        const blob = new Blob(recordedChunks, { type: 'audio/webm' });
        recordedChunks = [];

        const formData = new FormData();
        formData.append('recording', blob, `${CALL_TYPE}-call-${CALL_ID}.webm`);

        const endpoint = CALL_TYPE === 'video' ? 'video-calls' : 'phone-calls';
        const response = await fetch(
          `${API_URL}/groups/${GROUP_ID}/${endpoint}/${CALL_ID}/recording`,
          {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${AUTH_TOKEN}` },
            body: formData
          }
        );

        if (response.ok) {
          updateStatus('Recording uploaded successfully!', 'connected');
        } else {
          updateStatus('Upload failed: ' + response.statusText);
        }
      } catch (err) {
        console.error('[Recorder] Upload error:', err);
        updateStatus('Upload error: ' + err.message);
      }
    }

    function cleanup() {
      if (window.signalPollInterval) {
        clearInterval(window.signalPollInterval);
      }

      Object.values(peerConnections).forEach(pc => pc.close());
      peerConnections = {};

      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }

      if (audioContext) {
        audioContext.close();
      }
    }

    // Expose for Puppeteer control
    window.recorderReady = false;
    window.cleanup = cleanup;

    // Initialize
    init().then(() => {
      window.recorderReady = true;
    });
  </script>
</body>
</html>
